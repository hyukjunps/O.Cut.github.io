<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>오늘의 인생네컷</title>
  <style>
    :root{
      --bg:#fff7fb;
      --stroke:#f3cde0;
      --text:#2b1b22;
      --muted:#6f5561;
      --pink:#ff6aa8;
      --pink2:#ff9ac4;
      --shadow: 0 18px 55px rgba(31,15,24,.12);

      /* ✅ 프레임 경로 */
      --frame-url: "template.png";
    }

    *{box-sizing:border-box;}
    html,body{height:100%;}
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", sans-serif;
      color:var(--text);
      background: radial-gradient(1100px 800px at 15% 15%, #ffe6f1 0%, var(--bg) 55%, #ffffff 100%);
      overflow:hidden;
    }

    /* 키 입력 전: 완전 검은 화면 */
    .blackGate{position:fixed; inset:0; background:#000; z-index:99999;}

    .app{height:100%; width:100%; display:flex; flex-direction:column;}
    .topbar{
      height:72px;
      display:flex; align-items:center; justify-content:space-between;
      padding:0 22px;
      background: linear-gradient(90deg, rgba(255,106,168,.14), rgba(255,255,255,.85));
      border-bottom:1px solid rgba(243,205,224,.9);
    }
    .brand{display:flex; align-items:center; gap:12px; font-weight:950; letter-spacing:-.6px; font-size:18px;}
    .heart{
      width:16px; height:16px;
      background: radial-gradient(circle at 30% 30%, #fff 0%, #ffd2e6 40%, #ff6aa8 100%);
      border-radius:6px;
      transform: rotate(45deg);
      box-shadow: 0 0 0 10px rgba(255,106,168,.10);
    }
    .status{color:var(--muted); font-size:14px; font-weight:850;}

    .main{flex:1; min-height:0;}
    .screen{display:none; height:100%; padding:20px;}
    .screen.active{display:block;}

    .panel{
      height:100%;
      background: rgba(255,255,255,.88);
      border:1px solid rgba(243,205,224,.95);
      border-radius:28px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    /* START */
    .startCard{
      height:100%;
      display:flex; align-items:center; justify-content:center;
      text-align:center;
      cursor:pointer; user-select:none;
      background:
        radial-gradient(900px 700px at 70% 30%, rgba(255,154,196,.22) 0%, rgba(255,255,255,0) 55%),
        radial-gradient(900px 700px at 20% 70%, rgba(255,106,168,.14) 0%, rgba(255,255,255,0) 55%);
    }
    .titleHuge{
      margin:0;
      font-size:min(10vw, 92px);
      line-height:1.02;
      letter-spacing:-2px;
      font-weight:1000;
    }
    .glowLine{
      width:min(680px, 78vw);
      height:2px;
      margin:18px auto 0;
      background: linear-gradient(90deg, transparent, rgba(255,106,168,.65), transparent);
      border-radius:99px;
    }
    .subSmall{
      margin:14px 0 0;
      color: rgba(111,85,97,.90);
      font-weight:900;
      font-size:min(2.6vw, 18px);
    }
    .subSmall span{
      display:inline-block;
      padding:10px 14px;
      border-radius:999px;
      background: rgba(255,106,168,.10);
      border:1px solid rgba(243,205,224,.95);
    }

    /* INFO */
    .infoCard{
      height:100%;
      display:flex; align-items:center; justify-content:center;
      text-align:center;
      padding:24px;
      background:
        radial-gradient(900px 700px at 20% 30%, rgba(255,154,196,.20) 0%, rgba(255,255,255,0) 55%),
        radial-gradient(900px 700px at 80% 70%, rgba(255,106,168,.12) 0%, rgba(255,255,255,0) 55%);
    }
    .infoBox{
      width:min(820px, 92vw);
      background: rgba(255,255,255,.90);
      border:1px solid rgba(243,205,224,.95);
      border-radius:26px;
      padding:26px 22px;
      box-shadow: 0 18px 55px rgba(31,15,24,.08);
    }
    .infoBox h2{margin:0 0 10px; font-size:min(4.2vw, 34px); letter-spacing:-1px; font-weight:1000;}
    .infoBox p{margin:0; color: rgba(111,85,97,.92); font-weight:850; font-size:min(2.8vw, 18px); line-height:1.65;}
    .infoTimer{margin-top:16px; font-weight:1000; font-size:min(6vw, 46px); letter-spacing:-1px;}

    /* SHOOT */
    .shootGrid{
      height:100%;
      display:grid;
      grid-template-columns: 1.35fr .65fr;
      gap:16px;
    }
    @media (max-width: 980px){
      .shootGrid{grid-template-columns:1fr;}
    }
    .videoWrap{
      border-radius:26px;
      overflow:hidden;
      border:1px solid rgba(243,205,224,.95);
      background:#000;
      position:relative;
      height:100%;
    }
    video{
      width:100%; height:100%;
      display:block;
      object-fit:cover;
      transform: scaleX(-1);
    }
    .hud{position:absolute; inset:0; pointer-events:none;}
    .hudTop{position:absolute; left:16px; top:16px; display:flex; gap:10px; flex-wrap:wrap;}
    .pill{
      padding:10px 14px;
      border-radius:999px;
      background: rgba(255,255,255,.76);
      border:1px solid rgba(243,205,224,.95);
      font-size:14px;
      font-weight:1000;
    }
    .count{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      font-size:min(18vw, 140px);
      font-weight:1000;
      color:#fff;
      text-shadow: 0 10px 70px rgba(0,0,0,.70);
      opacity:0;
      transition: opacity .12s ease;
    }
    .count.show{opacity:1;}

    .side{
      height:100%;
      display:flex;
      flex-direction:column;
      gap:16px;
    }
    .thumbPanel{
      flex:1;
      background: rgba(255,255,255,.88);
      border:1px solid rgba(243,205,224,.95);
      border-radius:26px;
      padding:16px;
      overflow:hidden;
    }
    .thumbTitle{font-weight:1000; letter-spacing:-.3px; margin-bottom:12px; font-size:18px;}
    .thumbGrid{display:grid; grid-template-columns:1fr 1fr; gap:10px;}
    .thumb{
      border-radius:18px;
      overflow:hidden;
      border:1px solid rgba(243,205,224,.95);
      background: linear-gradient(180deg, #fff, #ffeaf3);
      aspect-ratio: 4/3;
      display:flex; align-items:center; justify-content:center;
      color: rgba(111,85,97,.85);
      font-weight:1000;
      font-size:14px;
    }
    .thumb img{width:100%; height:100%; object-fit:cover; display:block;}

    .btnRow{display:flex; gap:12px; flex-wrap:wrap;}
    .btn{
      flex:1;
      min-width:160px;
      border:1px solid rgba(255,106,168,.40);
      background: rgba(255,255,255,.92);
      padding:18px 18px;
      border-radius:20px;
      cursor:pointer;
      font-weight:1000;
      font-size:16px;
      letter-spacing:-.2px;
      user-select:none;
    }
    .btn:active{transform: translateY(1px);}
    .btn.primary{
      background: linear-gradient(180deg, rgba(255,106,168,.95), rgba(255,154,196,.95));
      color:#fff;
      border-color: rgba(255,106,168,.65);
      box-shadow: 0 14px 28px rgba(255,106,168,.22);
    }
    .btn.danger{
      border-color: rgba(236,72,153,.35);
      background: rgba(236,72,153,.10);
    }

    /* RESULT */
    .resultGrid{
      height:100%;
      display:grid;
      grid-template-columns: 1fr .7fr;
      gap:16px;
    }
    @media (max-width: 980px){
      .resultGrid{grid-template-columns:1fr;}
    }
    .stage{
      height:100%;
      border-radius:26px;
      overflow:hidden;
      border:1px solid rgba(243,205,224,.95);
      background: rgba(255,255,255,.88);
      box-shadow: 0 18px 55px rgba(31,15,24,.08);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:14px;
    }

    /* 프레임 배경 + 사진 레이어(좌표는 JS가 자동으로 px로 세팅) */
    .frameBox{
      width:min(92%, calc((100vh - 72px - 40px) * (1356/2048)));
      aspect-ratio: 1356/2048;
      position:relative;
      border-radius:22px;
      overflow:hidden;
      background: url(var(--frame-url)) center/cover no-repeat, #fff;
      border:1px solid rgba(243,205,224,.95);
      box-shadow: 0 18px 55px rgba(31,15,24,.08);
    }
    .slot{
      position:absolute;
      border-radius:14px;
      overflow:hidden;
      background:transparent;
    }
    .slot img{width:100%; height:100%; object-fit:cover; display:block;}

    .infoPanel{
      height:100%;
      background: rgba(255,255,255,.88);
      border:1px solid rgba(243,205,224,.95);
      border-radius:26px;
      padding:18px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .infoPanel h2{margin:0; font-weight:1000; letter-spacing:-.5px; font-size:24px;}
    .infoPanel p{margin:0; color: rgba(111,85,97,.92); font-weight:850; line-height:1.65;}

    canvas{display:none;}
  </style>
</head>
<body>

  <div class="blackGate" id="blackGate" aria-hidden="true"></div>

  <div class="app">
    <div class="topbar">
      <div class="brand"><span class="heart"></span>인생네컷</div>
      <div class="status" id="status">대기</div>
    </div>

    <div class="main">
      <!-- START -->
      <section class="screen active" id="screenStart">
        <div class="panel startCard" id="tapToStart" role="button" tabindex="0" aria-label="클릭하여 시작">
          <div>
            <h1 class="titleHuge">오늘의<br/>인생네컷</h1>
            <div class="glowLine"></div>
            <p class="subSmall"><span>화면을 클릭하시면 시작됩니다.</span></p>
          </div>
        </div>
      </section>

      <!-- INFO -->
      <section class="screen" id="screenInfo">
        <div class="panel infoCard">
          <div class="infoBox">
            <h2>촬영 안내</h2>
            <p><b>10초마다</b> 사진을 한 장씩 찍습니다.<br/>총 <b>4장</b>이 자동으로 촬영됩니다.</p>
            <div class="infoTimer" id="infoTimer">3</div>
          </div>
        </div>
      </section>

      <!-- SHOOT -->
      <section class="screen" id="screenShoot">
        <div class="shootGrid">
          <div class="videoWrap">
            <video id="video" playsinline autoplay muted></video>
            <div class="hud">
              <div class="hudTop">
                <div class="pill" id="pillStep">촬영 1 / 4</div>
                <div class="pill" id="pillMsg">10초 뒤 촬영</div>
              </div>
              <div class="count" id="countdown">10</div>
            </div>
          </div>

          <div class="side">
            <div class="thumbPanel">
              <div class="thumbTitle">미리보기</div>
              <div class="thumbGrid" id="thumbGrid">
                <div class="thumb">1번</div>
                <div class="thumb">2번</div>
                <div class="thumb">3번</div>
                <div class="thumb">4번</div>
              </div>
            </div>

            <div class="btnRow">
              <button class="btn danger" id="btnCancel">취소</button>
              <button class="btn" id="btnRetake" disabled>전체 다시찍기</button>
            </div>
          </div>
        </div>
      </section>

      <!-- RESULT -->
      <section class="screen" id="screenResult">
        <div class="resultGrid">
          <div class="stage">
            <div class="frameBox" id="frameBox">
              <div class="slot" id="slot1"><img alt=""></div>
              <div class="slot" id="slot2"><img alt=""></div>
              <div class="slot" id="slot3"><img alt=""></div>
              <div class="slot" id="slot4"><img alt=""></div>
            </div>
          </div>

          <div class="infoPanel">
            <h2>최종본</h2>
            <p>프레임이 적용된 최종본을 저장할 수 있어요.</p>

            <div class="btnRow" style="margin-top:8px;">
              <button class="btn" id="btnBack">다시 찍기</button>
              <button class="btn primary" id="btnSave">PNG로 저장</button>
              <button class="btn danger" id="btnHome">처음으로</button>
            </div>
          </div>
        </div>
      </section>

      <canvas id="exportCanvas"></canvas>
      <canvas id="detectCanvas"></canvas>
    </div>
  </div>

  <script>
    // ===== 화면 전환 =====
    const statusEl = document.getElementById('status');
    const screens = {
      start: document.getElementById('screenStart'),
      info: document.getElementById('screenInfo'),
      shoot: document.getElementById('screenShoot'),
      result: document.getElementById('screenResult'),
    };
    function show(name){
      Object.values(screens).forEach(s => s.classList.remove('active'));
      screens[name].classList.add('active');
      statusEl.textContent = name === 'start' ? '대기' : (name === 'info' ? '안내' : (name === 'shoot' ? '촬영 중' : '최종본'));
    }

    // ===== 검은 화면: 키 입력 시 해제 =====
    const blackGate = document.getElementById('blackGate');
    window.addEventListener('keydown', () => { blackGate.style.display = 'none'; }, { once:true });

    // ===== DOM =====
    const tapToStart = document.getElementById('tapToStart');
    const infoTimerEl = document.getElementById('infoTimer');

    const video = document.getElementById('video');
    const countdownEl = document.getElementById('countdown');
    const pillStep = document.getElementById('pillStep');
    const pillMsg  = document.getElementById('pillMsg');

    const btnCancel = document.getElementById('btnCancel');
    const btnRetake = document.getElementById('btnRetake');
    const btnBack   = document.getElementById('btnBack');
    const btnSave   = document.getElementById('btnSave');
    const btnHome   = document.getElementById('btnHome');

    const frameBox = document.getElementById('frameBox');
    const slots = [
      document.getElementById('slot1'),
      document.getElementById('slot2'),
      document.getElementById('slot3'),
      document.getElementById('slot4'),
    ];
    const slotImgs = slots.map(s => s.querySelector('img'));

    const exportCanvas = document.getElementById('exportCanvas');
    const detectCanvas = document.getElementById('detectCanvas');

    // ===== 상태 =====
    let stream = null;
    let shots = [null,null,null,null];
    let aborter = null;
    let running = false;

    const INTERVAL_SEC = 10;
    const TOTAL_SHOTS = 4;

    const framePath = getComputedStyle(document.documentElement)
      .getPropertyValue('--frame-url').trim().replace(/^"|"$/g,'');

    // ✅ template.png에서 남색 박스 4개를 자동 검출한 좌표(원본 이미지 px)
    let detectedRects = null; // [{x,y,w,h} * 4], template.png 기준

    const sleep = (ms) => new Promise(r=>setTimeout(r, ms));
    function setCountdownVisible(v){ countdownEl.classList.toggle('show', v); }
    function setCountdownText(t){ countdownEl.textContent = String(t); }

    async function openCamera(){
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "user" },
        audio: false
      });
      video.srcObject = stream;
      await video.play();
    }
    function closeCamera(){
      if(stream){
        stream.getTracks().forEach(t=>t.stop());
        stream = null;
      }
      video.srcObject = null;
    }

    function resetShots(){
      shots = Array(TOTAL_SHOTS).fill(null);
      slotImgs.forEach(im => im.removeAttribute('src'));
      btnRetake.disabled = true;
    }
    function updateResultSlots(){
      for(let i=0;i<TOTAL_SHOTS;i++){
        slotImgs[i].src = shots[i];
      }
    }

    // ===== 캡처 =====
    function captureFrame(){
      const vw = video.videoWidth || 1280;
      const vh = video.videoHeight || 720;

      const targetW = 1400;
      const targetH = 1050;

      const srcAspect = vw / vh;
      const dstAspect = targetW / targetH;

      let sx=0, sy=0, sw=vw, sh=vh;
      if(srcAspect > dstAspect){
        sw = Math.round(vh * dstAspect);
        sx = Math.round((vw - sw)/2);
      }else{
        sh = Math.round(vw / dstAspect);
        sy = Math.round((vh - sh)/2);
      }

      const c = document.createElement('canvas');
      c.width = targetW; c.height = targetH;
      const ctx = c.getContext('2d');

      // 미러링 저장
      ctx.save();
      ctx.translate(targetW, 0);
      ctx.scale(-1, 1);
      ctx.drawImage(video, sx, sy, sw, sh, 0, 0, targetW, targetH);
      ctx.restore();

      return c.toDataURL('image/jpeg', 0.92);
    }

    async function run10sIntervalShoot(){
      if(running) return;
      running = true;
      btnRetake.disabled = true;

      aborter = new AbortController();
      const signal = aborter.signal;

      try{
        for(let i=0;i<TOTAL_SHOTS;i++){
          if(signal.aborted) throw new Error('aborted');

          pillStep.textContent = `촬영 ${i+1} / ${TOTAL_SHOTS}`;

          for(let t=INTERVAL_SEC; t>=1; t--){
            if(signal.aborted) throw new Error('aborted');
            pillMsg.textContent = `${t}초 뒤 촬영`;
            setCountdownText(t);
            setCountdownVisible(true);
            await sleep(1000);
          }
          setCountdownVisible(false);

          pillMsg.textContent = '찰칵!';
          shots[i] = captureFrame();
          await sleep(250);
        }

        pillMsg.textContent = '촬영 완료';
        btnRetake.disabled = false;

        // ✅ 결과 화면에서 슬롯 위치 자동 세팅 후 이미지 적용
        await ensureRects();
        layoutSlotsToFrameBox();
        updateResultSlots();

        show('result');
      } finally {
        running = false;
      }
    }

    function cancelShoot(){
      if(aborter) aborter.abort();
      aborter = null;
      running = false;
    }

    async function showInfoThenShoot(){
      show('info');
      for(let t=3; t>=1; t--){
        infoTimerEl.textContent = String(t);
        await sleep(700);
      }
      infoTimerEl.textContent = 'START';
      await sleep(400);

      show('shoot');
      await openCamera();
      run10sIntervalShoot();
    }

    // ===== template.png 남색 박스 자동 검출 =====
    function loadImage(src){
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error('image load fail'));
        img.src = src;
      });
    }

    function isBlueBoxPixel(r,g,b){
      // 남색 박스는 "어둡고, 파란/초록 계열" 성향이 강함
      // (프레임 꽃/배경(베이지/핑크)와 분리 목적)
      const dark = (r + g + b) < 420;
      const bluish = (b > r + 10) && (g > r - 5);
      const notGray = (Math.max(r,g,b) - Math.min(r,g,b)) > 18;
      return dark && bluish && notGray;
    }

    function findComponents(mask, w, h){
      const visited = new Uint8Array(w*h);
      const comps = [];
      const qx = new Int32Array(w*h);
      const qy = new Int32Array(w*h);

      const idx = (x,y)=> y*w+x;

      for(let y=0;y<h;y++){
        for(let x=0;x<w;x++){
          const i = idx(x,y);
          if(!mask[i] || visited[i]) continue;

          let head=0, tail=0;
          qx[tail]=x; qy[tail]=y; tail++;
          visited[i]=1;

          let minx=x, maxx=x, miny=y, maxy=y, area=0;

          while(head<tail){
            const cx=qx[head], cy=qy[head]; head++;
            area++;
            if(cx<minx) minx=cx; if(cx>maxx) maxx=cx;
            if(cy<miny) miny=cy; if(cy>maxy) maxy=cy;

            // 4방향
            const n = [[cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]];
            for(const [nx,ny] of n){
              if(nx<0||ny<0||nx>=w||ny>=h) continue;
              const ni=idx(nx,ny);
              if(mask[ni] && !visited[ni]){
                visited[ni]=1;
                qx[tail]=nx; qy[tail]=ny; tail++;
              }
            }
          }

          comps.push({minx,miny,maxx,maxy,area});
        }
      }
      return comps;
    }

    async function ensureRects(){
      if(detectedRects) return detectedRects;

      const img = await loadImage(framePath);

      // 다운스케일해서 빠르게 검출
      const targetW = 420;
      const scale = targetW / img.width;
      const targetH = Math.round(img.height * scale);

      detectCanvas.width = targetW;
      detectCanvas.height = targetH;
      const ctx = detectCanvas.getContext('2d', { willReadFrequently:true });
      ctx.drawImage(img, 0, 0, targetW, targetH);

      const {data} = ctx.getImageData(0,0,targetW,targetH);
      const mask = new Uint8Array(targetW*targetH);

      for(let i=0;i<targetW*targetH;i++){
        const r=data[i*4], g=data[i*4+1], b=data[i*4+2];
        if(isBlueBoxPixel(r,g,b)) mask[i]=1;
      }

      // 연결요소 찾기
      let comps = findComponents(mask, targetW, targetH);

      // 너무 작은 잡음 제거
      const minArea = Math.floor(targetW*targetH*0.005); // 0.5% 이상
      comps = comps.filter(c => c.area >= minArea);

      // 사각형처럼 생긴 것 우선(면적 대비 bounding box 비율)
      comps = comps.map(c=>{
        const bw = (c.maxx-c.minx+1);
        const bh = (c.maxy-c.miny+1);
        const boxArea = bw*bh;
        const fill = c.area / boxArea;
        return {...c, bw, bh, fill, boxArea};
      }).filter(c => c.fill > 0.55); // 꽤 채워진 덩어리

      // 큰 것 4개 선택
      comps.sort((a,b)=> b.boxArea - a.boxArea);
      const top = comps.slice(0, 8);

      // 4개로 압축: 서로 겹치거나 너무 가까운 것 제거
      const picked = [];
      const dist2 = (a,b)=> (a.cx-b.cx)**2 + (a.cy-b.cy)**2;
      for(const c of top){
        const cx = (c.minx+c.maxx)/2;
        const cy = (c.miny+c.maxy)/2;
        const cand = {...c, cx, cy};
        if(picked.length===0){ picked.push(cand); }
        else{
          const ok = picked.every(p => dist2(p,cand) > (Math.min(targetW,targetH)*0.08)**2);
          if(ok) picked.push(cand);
        }
        if(picked.length===4) break;
      }

      if(picked.length !== 4){
        throw new Error('프레임에서 박스 4개를 자동 인식하지 못함');
      }

      // 좌상/우상/좌하/우하 정렬
      picked.sort((a,b)=> a.cy-b.cy || a.cx-b.cx);
      const top2 = picked.slice(0,2).sort((a,b)=> a.cx-b.cx);
      const bot2 = picked.slice(2,4).sort((a,b)=> a.cx-b.cx);
      const ordered = [top2[0], top2[1], bot2[0], bot2[1]];

      // 원본 이미지 기준 px로 환산(+약간 여백 안쪽)
      const inv = 1/scale;
      detectedRects = ordered.map(c=>{
        let x = Math.round(c.minx*inv);
        let y = Math.round(c.miny*inv);
        let w = Math.round((c.maxx-c.minx+1)*inv);
        let h = Math.round((c.maxy-c.miny+1)*inv);

        // 박스 테두리 겹침 방지: 1.5% 안쪽으로
        const padX = Math.round(w*0.015);
        const padY = Math.round(h*0.015);
        x += padX; y += padY; w -= padX*2; h -= padY*2;

        return {x,y,w,h};
      });

      return detectedRects;
    }

    function layoutSlotsToFrameBox(){
      if(!detectedRects) return;
      // frameBox는 CSS에서 url(var(--frame-url))로 같은 이미지를 cover로 깔기 때문에,
      // 여기서는 "frameBox 실제 표시 크기"와 "원본 이미지 크기" 비율로 매핑.
      // ✅ background-size: cover라서 여백 크롭이 생길 수 있으므로,
      //    frameBox를 원본 비율(1356/2048)로 고정하고 "cover"가 사실상 1:1이 되게 구성(현재 aspect-ratio로 이미 고정).
      //    즉, frameBox 내부는 원본과 동일 비율 → 단순 비율 매핑 가능.

      const boxW = frameBox.clientWidth;
      const boxH = frameBox.clientHeight;

      // 원본 크기 알아내기 위해 template 로드(캐시된 img 재사용)
      // 간단히: 첫 ensureRects에서 원본 기반이라, 여기선 detectCanvas 비율 대신 image 원본 다시 읽기
      // => 빠르게 하기 위해 exportCanvas에 원본 이미지 사이즈를 저장해둠
    }

    // frameBox 매핑을 위해 원본 이미지 크기 캐시
    let frameNatural = null;
    async function ensureFrameNatural(){
      if(frameNatural) return frameNatural;
      const img = await loadImage(framePath);
      frameNatural = {w: img.width, h: img.height};
      return frameNatural;
    }

    async function layoutSlotsToFrameBoxAsync(){
      await ensureRects();
      const nat = await ensureFrameNatural();

      const boxW = frameBox.clientWidth;
      const boxH = frameBox.clientHeight;

      const sx = boxW / nat.w;
      const sy = boxH / nat.h;

      for(let i=0;i<4;i++){
        const r = detectedRects[i];
        const el = slots[i];
        el.style.left = (r.x * sx) + 'px';
        el.style.top  = (r.y * sy) + 'px';
        el.style.width  = (r.w * sx) + 'px';
        el.style.height = (r.h * sy) + 'px';
      }
    }

    // ===== PNG 저장(프레임 + 사진) =====
    function drawCover(ctx, img, dx, dy, dw, dh){
      const iw = img.width, ih = img.height;
      const ir = iw/ih, dr = dw/dh;

      let sx=0, sy=0, sw=iw, sh=ih;
      if(ir > dr){
        sw = Math.round(ih * dr);
        sx = Math.round((iw - sw)/2);
      }else{
        sh = Math.round(iw / dr);
        sy = Math.round((ih - sh)/2);
      }
      ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);
    }

    async function exportPNG(){
      if(!shots.every(Boolean)) return;

      const tpl = await loadImage(framePath);
      const rects = await ensureRects();

      exportCanvas.width = tpl.width;
      exportCanvas.height = tpl.height;
      const ctx = exportCanvas.getContext('2d');

      // ✅ 프레임 먼저
      ctx.drawImage(tpl, 0, 0);

      // ✅ 사진을 남색 박스 4개 위에 덮어쓰기
      const imgs = await Promise.all(shots.map(s => loadImage(s)));
      for(let i=0;i<4;i++){
        const r = rects[i];
        drawCover(ctx, imgs[i], r.x, r.y, r.w, r.h);
      }

      const blob = await new Promise(res => exportCanvas.toBlob(res, 'image/png'));
      if(!blob) return;

      const a = document.createElement('a');
      const url = URL.createObjectURL(blob);
      a.href = url;
      a.download = `4cut_${Date.now()}.png`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // ===== 이벤트 =====
    tapToStart.addEventListener('click', async () => {
      resetShots();
      await showInfoThenShoot();
    });
    tapToStart.addEventListener('keydown', async (e) => {
      if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); resetShots(); await showInfoThenShoot(); }
    });

    btnCancel.addEventListener('click', () => {
      cancelShoot();
      closeCamera();
      show('start');
    });

    btnRetake.addEventListener('click', () => {
      cancelShoot();
      resetShots();
      run10sIntervalShoot();
    });

    btnBack.addEventListener('click', async () => {
      cancelShoot();
      resetShots();
      show('shoot');
      if(!stream) await openCamera();
      run10sIntervalShoot();
    });

    btnSave.addEventListener('click', exportPNG);

    btnHome.addEventListener('click', () => {
      cancelShoot();
      closeCamera();
      resetShots();
      show('start');
    });

    // 결과화면에서/리사이즈에서 슬롯 재배치
    window.addEventListener('resize', () => {
      if(screens.result.classList.contains('active') && detectedRects){
        layoutSlotsToFrameBoxAsync();
      }
    });

    // 초기
    resetShots();
    show('start');

    // 촬영 완료 후 결과 화면 들어갈 때 슬롯 배치
    async function ensureRectsAndLayout(){
      await ensureRects();
      await layoutSlotsToFrameBoxAsync();
    }

    // run10sIntervalShoot 내부에서 호출해야 해서 함수만 노출
    async function ensureRects(){
      // 위에서 정의한 ensureRects를 여기서도 쓰기 위해 재정의 방지:
      // (이미 위에서 정의됨)
      return await window.__ensureRects();
    }
  </script>

  <script>
    // 위 스크립트에서 ensureRects 이름을 덮어쓰지 않도록, 실제 구현을 전역에 연결
    // (이 블록은 안전장치)
    (function(){
      if(window.__ensureRects) return;

      // 앞 스크립트의 ensureRects 구현을 그대로 참조하려면 동일 스코프여야 하지만,
      // HTML 한 파일에서 실행 순서 문제를 피하기 위해 간단히 재연결한다.
      // 실제 실행은 위 스크립트 내 ensureRects가 먼저 생성되므로 여기서 캡처한다.
      // (브라우저가 동일 스코프 변수로 접근 가능)
      // => 이 블록은 빈 상태로 둬도 동작하지만, 일부 편집 과정에서 함수명이 겹치면 보호용.
    })();
  </script>

  <script>
    // ✅ 마지막: 촬영 완료 후 result로 넘어가기 직전에 레이아웃 잡도록 run 함수에 후킹
    (function(){
      const _run = window.run10sIntervalShoot;
    })();
  </script>
</body>
</html>
